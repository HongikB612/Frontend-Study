**컴퓨터** : **CPU** (연산 담당) + **메모리** (기억 담당)

→ **메모리** : **1바이트 단위**로 데이터를 **저장**하거나 **읽을** 수 있고, **고유의 주소**를 갖는 **메모리 셀**의 집합체

자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음

→ 이유 : 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 수 있기 때문

즉, **변수**를 통해 **간접적**으로 메모리를 제어함

**변수** 
---
하나의 값을 저장하기 위해 **확보한 메모리 공간 자체** 또는 그 **메모리 공간을 식별**하기 위해 붙여진 이름

↔️ **값의 위치**를 가리키는 상징적인 이름


값의 생성과 변수에의 할당

**할당** 
---

변수에 값을 저장하는 것

**참조**
---

변수에 저장된 값을 읽어 들이는 것

**식별자**

어떤 값을 구별해서 식별할 수 있는 고유한 이름

BUT, **값**이 아니라 **메모지 주소**를 기억하는 것

**변수 선언**

변수를 사용할 때, **var*(ES5)*, let, const*(ES6)*** 라는 키워드 사용

`var score; //변수 선언문`

→ 변수 이름을 등록 +  값을 저장할 메모리 공간 확보

**var ↔ let & const**
---
- var
    - ES5
    - 지금도 널리 사용중인 키워드
    - **자동 초기화 (undefined 할당)**
- let & const
    - ES6
    - var의 여러 단점을 보완하기 위해 나옴

 **변수 호이스팅 (variable hoisting)**
--
변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징

→ 즉, **변수 선언** : 소스코드가 순차적으로 실행되는 시점인 **런타임 이전에 먼저 실행**

**값의 할당**

소스 코드가 순차적으로 실행되는 시점인 **런타임에 실행**

```jsx
console.log(score);  // undefined

var score = 80; // 변수 선언 + 값의 할당

console.log(score);  // 80
```

**const**
--
변수에 재할당 X